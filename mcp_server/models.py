# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T14:20:48+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, confloat, conint, constr


class AmazonResourceName(RootModel[constr(min_length=1, max_length=1011)]):
    root: constr(min_length=1, max_length=1011)


class AnnotationKey(RootModel[str]):
    root: str


class AttributeKey(RootModel[constr(min_length=1, max_length=32)]):
    root: constr(min_length=1, max_length=32)


class AttributeValue(RootModel[constr(min_length=1, max_length=32)]):
    root: constr(min_length=1, max_length=32)


class Boolean(RootModel[bool]):
    root: bool


class BorrowCount(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class ClientID(RootModel[constr(min_length=24, max_length=24)]):
    root: constr(min_length=24, max_length=24)


class DeleteGroupResult(BaseModel):
    pass


class DeleteResourcePolicyResult(BaseModel):
    pass


class Double(RootModel[float]):
    root: float


class EC2InstanceId(RootModel[constr(max_length=20)]):
    root: constr(max_length=20)


class EncryptionKeyId(RootModel[constr(min_length=1, max_length=3000)]):
    root: constr(min_length=1, max_length=3000)


class EncryptionStatus(Enum):
    UPDATING = 'UPDATING'
    ACTIVE = 'ACTIVE'


class EncryptionType(Enum):
    NONE = 'NONE'
    KMS = 'KMS'


class EntitySelectorExpression(RootModel[constr(min_length=1, max_length=500)]):
    root: constr(min_length=1, max_length=500)


class EventSummaryText(RootModel[str]):
    root: str


class FilterExpression(RootModel[str]):
    root: str


class FixedRate(RootModel[confloat(ge=0.0, le=1.0)]):
    root: confloat(ge=0.0, le=1.0)


class GetEncryptionConfigRequest(BaseModel):
    pass


class GetGroupsNextToken(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class GetGroupsRequest(BaseModel):
    NextToken: Optional[GetGroupsNextToken] = None


class GetInsightEventsMaxResults(RootModel[conint(ge=1, le=50)]):
    root: conint(ge=1, le=50)


class GetInsightSummariesMaxResults(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class GroupARN(RootModel[constr(min_length=1, max_length=400)]):
    root: constr(min_length=1, max_length=400)


class GroupName(RootModel[constr(min_length=1, max_length=32)]):
    root: constr(min_length=1, max_length=32)


class HTTPMethod(RootModel[constr(max_length=10)]):
    root: constr(max_length=10)


class Host(RootModel[constr(max_length=64)]):
    root: constr(max_length=64)


class Hostname(RootModel[constr(max_length=255)]):
    root: constr(max_length=255)


class InsightCategory(Enum):
    FAULT = 'FAULT'


class InsightCategoryList(RootModel[List[InsightCategory]]):
    root: List[InsightCategory]


class InsightId(
    RootModel[
        constr(
            pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}'
        )
    ]
):
    root: constr(
        pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}'
    )


class InsightState(Enum):
    ACTIVE = 'ACTIVE'
    CLOSED = 'CLOSED'


class InsightStateList(RootModel[List[InsightState]]):
    root: List[InsightState] = Field(..., max_length=1, min_length=0)


class InsightSummaryText(RootModel[str]):
    root: str


class Integer(RootModel[int]):
    root: int


class InvalidPolicyRevisionIdException(RootModel[Any]):
    root: Any


class InvalidRequestException(RootModel[Any]):
    root: Any


class LockoutPreventionException(RootModel[Any]):
    root: Any


class MalformedPolicyDocumentException(RootModel[Any]):
    root: Any


class NullableBoolean(RootModel[bool]):
    root: bool


class NullableDouble(RootModel[float]):
    root: float


class NullableInteger(RootModel[int]):
    root: int


class NullableLong(RootModel[int]):
    root: int


class PolicyCountLimitExceededException(RootModel[Any]):
    root: Any


class PolicyDocument(RootModel[str]):
    root: str


class PolicyName(
    RootModel[constr(pattern=r'[\w+=,.@-]+', min_length=1, max_length=128)]
):
    root: constr(pattern=r'[\w+=,.@-]+', min_length=1, max_length=128)


class PolicyRevisionId(RootModel[str]):
    root: str


class PolicySizeLimitExceededException(RootModel[Any]):
    root: Any


class Priority(RootModel[conint(ge=1, le=9999)]):
    root: conint(ge=1, le=9999)


class PutEncryptionConfigRequest(BaseModel):
    KeyId: Optional[EncryptionKeyId] = None
    Type: EncryptionType


class PutResourcePolicyRequest(BaseModel):
    BypassPolicyLockoutCheck: Optional[Boolean] = None
    PolicyDocument_1: PolicyDocument = Field(..., alias='PolicyDocument')
    PolicyName_1: PolicyName = Field(..., alias='PolicyName')
    PolicyRevisionId_1: Optional[PolicyRevisionId] = Field(
        None, alias='PolicyRevisionId'
    )


class PutTelemetryRecordsResult(BaseModel):
    pass


class RequestCount(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class RequestImpactStatistics(BaseModel):
    FaultCount: Optional[NullableLong] = None
    OkCount: Optional[NullableLong] = None
    TotalCount: Optional[NullableLong] = None


class ReservoirSize(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class ResourceARN(RootModel[constr(max_length=500)]):
    root: constr(max_length=500)


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class ResourcePolicyNextToken(RootModel[constr(min_length=1, max_length=100)]):
    root: constr(min_length=1, max_length=100)


class RuleLimitExceededException(RootModel[Any]):
    root: Any


class RuleName(RootModel[constr(min_length=1, max_length=32)]):
    root: constr(min_length=1, max_length=32)


class SampledCount(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class SamplingStrategyName(Enum):
    PartialScan = 'PartialScan'
    FixedRate = 'FixedRate'


class SegmentDocument(RootModel[constr(min_length=1)]):
    root: constr(min_length=1)


class SegmentId(RootModel[str]):
    root: str


class ServiceName(RootModel[constr(max_length=64)]):
    root: constr(max_length=64)


class ServiceType(RootModel[constr(max_length=64)]):
    root: constr(max_length=64)


class String(RootModel[str]):
    root: str


class TagKey(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=200, min_length=0)


class TagResourceResponse(BaseModel):
    pass


class TagValue(RootModel[constr(min_length=0, max_length=256)]):
    root: constr(min_length=0, max_length=256)


class ThrottledException(RootModel[Any]):
    root: Any


class TimeRangeType(Enum):
    TraceId = 'TraceId'
    Event = 'Event'


class Timestamp(RootModel[datetime]):
    root: datetime


class Token(RootModel[constr(min_length=1, max_length=2000)]):
    root: constr(min_length=1, max_length=2000)


class TooManyTagsException(RootModel[Any]):
    root: Any


class TraceId(RootModel[constr(min_length=1, max_length=35)]):
    root: constr(min_length=1, max_length=35)


class TraceIdList(RootModel[List[TraceId]]):
    root: List[TraceId]


class TraceSegmentDocument(RootModel[str]):
    root: str


class TraceSegmentDocumentList(RootModel[List[TraceSegmentDocument]]):
    root: List[TraceSegmentDocument]


class URLPath(RootModel[constr(max_length=128)]):
    root: constr(max_length=128)


class UnprocessedStatistics(BaseModel):
    ErrorCode: Optional[String] = None
    Message: Optional[String] = None
    RuleName: Optional[String] = None


class UnprocessedStatisticsList(RootModel[List[UnprocessedStatistics]]):
    root: List[UnprocessedStatistics]


class UnprocessedTraceIdList(RootModel[List[TraceId]]):
    root: List[TraceId]


class UnprocessedTraceSegment(BaseModel):
    ErrorCode: Optional[String] = None
    Id: Optional[String] = None
    Message: Optional[String] = None


class UnprocessedTraceSegmentList(RootModel[List[UnprocessedTraceSegment]]):
    root: List[UnprocessedTraceSegment]


class UntagResourceRequest(BaseModel):
    ResourceARN: AmazonResourceName
    TagKeys: TagKeyList


class UntagResourceResponse(BaseModel):
    pass


class Version(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class InsightsConfiguration(BaseModel):
    InsightsEnabled: Optional[NullableBoolean] = None
    NotificationsEnabled: Optional[NullableBoolean] = None


class DeleteGroupPostRequest(BaseModel):
    GroupARN: Optional[constr(min_length=1, max_length=400)] = Field(
        None, description='The ARN of the group that was generated on creation.'
    )
    GroupName: Optional[constr(min_length=1, max_length=32)] = Field(
        None, description='The case-sensitive name of the group.'
    )


class DeleteResourcePolicyPostRequest(BaseModel):
    PolicyName: constr(pattern=r'[\w+=,.@-]+', min_length=1, max_length=128) = Field(
        ..., description='The name of the resource policy to delete.'
    )
    PolicyRevisionId: Optional[str] = Field(
        None,
        description='Specifies a specific policy revision to delete. Provide a <code>PolicyRevisionId</code> to ensure an atomic delete operation. If the provided revision id does not match the latest policy revision id, an <code>InvalidPolicyRevisionIdException</code> exception is returned. ',
    )


class DeleteSamplingRulePostRequest(BaseModel):
    RuleARN: Optional[str] = Field(
        None,
        description='The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.',
    )
    RuleName: Optional[str] = Field(
        None,
        description='The name of the sampling rule. Specify a rule by either name or ARN, but not both.',
    )


class GetGroupPostRequest(BaseModel):
    GroupARN: Optional[constr(min_length=1, max_length=400)] = Field(
        None, description='The ARN of the group that was generated on creation.'
    )
    GroupName: Optional[constr(min_length=1, max_length=32)] = Field(
        None, description='The case-sensitive name of the group.'
    )


class GetSamplingRulesPostRequest(BaseModel):
    NextToken: Optional[str] = Field(None, description='Pagination token.')


class GroupsPostRequest(BaseModel):
    NextToken: Optional[constr(min_length=1, max_length=100)] = Field(
        None, description='Pagination token.'
    )


class InsightPostRequest(BaseModel):
    InsightId: constr(
        pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}'
    ) = Field(
        ...,
        description="The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.",
    )


class InsightEventsPostRequest(BaseModel):
    InsightId: constr(
        pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}'
    ) = Field(
        ...,
        description="The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.",
    )
    MaxResults: Optional[conint(ge=1, le=50)] = Field(
        None, description='Used to retrieve at most the specified value of events.'
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='Specify the pagination token returned by a previous request to retrieve the next page of events. ',
    )


class InsightImpactGraphPostRequest(BaseModel):
    EndTime: datetime = Field(
        ...,
        description="The estimated end time of the insight, in Unix time seconds. The EndTime is exclusive of the value provided. The time range between the start time and end time can't be more than six hours. ",
    )
    InsightId: constr(
        pattern=r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}'
    ) = Field(
        ...,
        description="The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.",
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None,
        description='Specify the pagination token returned by a previous request to retrieve the next page of results. ',
    )
    StartTime: datetime = Field(
        ...,
        description="The estimated start time of the insight, in Unix time seconds. The StartTime is inclusive of the value provided and can't be more than 30 days old.",
    )


class InsightSummariesPostRequest(BaseModel):
    EndTime: datetime = Field(
        ...,
        description="The end of the time frame in which the insights ended. The end time can't be more than 30 days old.",
    )
    GroupARN: Optional[constr(min_length=1, max_length=400)] = Field(
        None,
        description="The Amazon Resource Name (ARN) of the group. Required if the GroupName isn't provided.",
    )
    GroupName: Optional[constr(min_length=1, max_length=32)] = Field(
        None,
        description="The name of the group. Required if the GroupARN isn't provided.",
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to display.'
    )
    NextToken: Optional[constr(min_length=1, max_length=2000)] = Field(
        None, description='Pagination token.'
    )
    StartTime: datetime = Field(
        ...,
        description="The beginning of the time frame in which the insights started. The start time can't be more than 30 days old.",
    )
    States: Optional[List[InsightState]] = Field(
        None, description='The list of insight states. ', max_length=1, min_length=0
    )


class ListResourcePoliciesPostRequest(BaseModel):
    NextToken: Optional[constr(min_length=1, max_length=100)] = Field(
        None, description='Not currently supported.'
    )


class ListTagsForResourcePostRequest(BaseModel):
    NextToken: Optional[str] = Field(
        None,
        description='A pagination token. If multiple pages of results are returned, use the <code>NextToken</code> value returned with the current page of results as the value of this parameter to get the next page of results.',
    )
    ResourceARN: constr(min_length=1, max_length=1011) = Field(
        ...,
        description='The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.',
    )


class Type(Enum):
    NONE = 'NONE'
    KMS = 'KMS'


class PutEncryptionConfigPostRequest(BaseModel):
    KeyId: Optional[constr(min_length=1, max_length=3000)] = Field(
        None,
        description='<p>An Amazon Web Services KMS key in one of the following formats:</p> <ul> <li> <p> <b>Alias</b> - The name of the key. For example, <code>alias/MyKey</code>.</p> </li> <li> <p> <b>Key ID</b> - The KMS key ID of the key. For example, <code>ae4aa6d49-a4d8-9df9-a475-4ff6d7898456</code>. Amazon Web Services X-Ray does not support asymmetric KMS keys.</p> </li> <li> <p> <b>ARN</b> - The full Amazon Resource Name of the key ID or alias. For example, <code>arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456</code>. Use this format to specify a key in a different account.</p> </li> </ul> <p>Omit this key if you set <code>Type</code> to <code>NONE</code>.</p>',
    )
    Type_1: Type = Field(
        ...,
        alias='Type',
        description='The type of encryption. Set to <code>KMS</code> to use your own key for encryption. Set to <code>NONE</code> for default encryption.',
    )


class PutResourcePolicyPostRequest(BaseModel):
    BypassPolicyLockoutCheck: Optional[bool] = Field(
        None,
        description='<p>A flag to indicate whether to bypass the resource policy lockout safety check.</p> <important> <p>Setting this value to true increases the risk that the policy becomes unmanageable. Do not set this value to true indiscriminately.</p> </important> <p>Use this parameter only when you include a policy in the request and you intend to prevent the principal that is making the request from making a subsequent <code>PutResourcePolicy</code> request.</p> <p>The default value is false.</p>',
    )
    PolicyDocument: str = Field(
        ..., description='The resource policy document, which can be up to 5kb in size.'
    )
    PolicyName: constr(pattern=r'[\w+=,.@-]+', min_length=1, max_length=128) = Field(
        ...,
        description='The name of the resource policy. Must be unique within a specific Amazon Web Services account.',
    )
    PolicyRevisionId: Optional[str] = Field(
        None,
        description='<p>Specifies a specific policy revision, to ensure an atomic create operation. By default the resource policy is created if it does not exist, or updated with an incremented revision id. The revision id is unique to each policy in the account.</p> <p>If the policy revision id does not match the latest revision id, the operation will fail with an <code>InvalidPolicyRevisionIdException</code> exception. You can also provide a <code>PolicyRevisionId</code> of 0. In this case, the operation will fail with an <code>InvalidPolicyRevisionIdException</code> exception if a resource policy with the same name already exists. </p>',
    )


class SamplingStatisticSummariesPostRequest(BaseModel):
    NextToken: Optional[str] = Field(None, description='Pagination token.')


class ServiceGraphPostRequest(BaseModel):
    EndTime: datetime = Field(
        ..., description='The end of the timeframe for which to generate a graph.'
    )
    GroupARN: Optional[constr(min_length=1, max_length=400)] = Field(
        None,
        description='The Amazon Resource Name (ARN) of a group based on which you want to generate a graph.',
    )
    GroupName: Optional[constr(min_length=1, max_length=32)] = Field(
        None,
        description='The name of a group based on which you want to generate a graph.',
    )
    NextToken: Optional[str] = Field(None, description='Pagination token.')
    StartTime: datetime = Field(
        ..., description='The start of the time frame for which to generate a graph.'
    )


class TimeSeriesServiceStatisticsPostRequest(BaseModel):
    EndTime: datetime = Field(
        ..., description='The end of the time frame for which to aggregate statistics.'
    )
    EntitySelectorExpression: Optional[constr(min_length=1, max_length=500)] = Field(
        None,
        description='A filter expression defining entities that will be aggregated for statistics. Supports ID, service, and edge functions. If no selector expression is specified, edge statistics are returned. ',
    )
    ForecastStatistics: Optional[bool] = Field(
        None,
        description='The forecasted high and low fault count values. Forecast enabled requests require the EntitySelectorExpression ID be provided.',
    )
    GroupARN: Optional[constr(min_length=1, max_length=400)] = Field(
        None,
        description='The Amazon Resource Name (ARN) of the group for which to pull statistics from.',
    )
    GroupName: Optional[constr(min_length=1, max_length=32)] = Field(
        None,
        description='The case-sensitive name of the group for which to pull statistics from.',
    )
    NextToken: Optional[str] = Field(None, description='Pagination token.')
    Period: Optional[int] = Field(None, description='Aggregation period in seconds.')
    StartTime: datetime = Field(
        ...,
        description='The start of the time frame for which to aggregate statistics.',
    )


class TraceGraphPostRequest(BaseModel):
    NextToken: Optional[str] = Field(None, description='Pagination token.')
    TraceIds: List[TraceId] = Field(
        ..., description='Trace IDs of requests for which to generate a service graph.'
    )


class TraceSegmentsPostRequest(BaseModel):
    TraceSegmentDocuments: List[TraceSegmentDocument] = Field(
        ...,
        description='A string containing a JSON document defining one or more segments or subsegments.',
    )


class SamplingStrategy(BaseModel):
    Name: Optional[SamplingStrategyName] = None
    Value: Optional[NullableDouble] = None


class TraceSummariesPostRequest(BaseModel):
    EndTime: datetime = Field(
        ..., description='The end of the time frame for which to retrieve traces.'
    )
    FilterExpression: Optional[str] = Field(
        None,
        description='Specify a filter expression to retrieve trace summaries for services or requests that meet certain requirements.',
    )
    NextToken: Optional[str] = Field(
        None,
        description='Specify the pagination token returned by a previous request to retrieve the next page of results.',
    )
    Sampling: Optional[bool] = Field(
        None,
        description='Set to <code>true</code> to get summaries for only a subset of available traces.',
    )
    SamplingStrategy_1: Optional[SamplingStrategy] = Field(
        None,
        alias='SamplingStrategy',
        description='The name and value of a sampling rule to apply to a trace summary.',
    )
    StartTime: datetime = Field(
        ..., description='The start of the time frame for which to retrieve traces.'
    )
    TimeRangeType_1: Optional[TimeRangeType] = Field(
        None,
        alias='TimeRangeType',
        description='A parameter to indicate whether to query trace summaries by TraceId or Event time.',
    )


class TracesPostRequest(BaseModel):
    NextToken: Optional[str] = Field(None, description='Pagination token.')
    TraceIds: List[TraceId] = Field(
        ...,
        description='Specify the trace IDs of requests for which to retrieve segments.',
    )


class UntagResourcePostRequest(BaseModel):
    ResourceARN: constr(min_length=1, max_length=1011) = Field(
        ...,
        description='The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.',
    )
    TagKeys: List[TagKey] = Field(
        ...,
        description='Keys for one or more tags that you want to remove from an X-Ray group or sampling rule.',
        max_length=200,
        min_length=0,
    )


class UpdateGroupPostRequest(BaseModel):
    FilterExpression: Optional[str] = Field(
        None,
        description='The updated filter expression defining criteria by which to group traces.',
    )
    GroupARN: Optional[constr(min_length=1, max_length=400)] = Field(
        None, description='The ARN that was generated upon creation.'
    )
    GroupName: Optional[constr(min_length=1, max_length=32)] = Field(
        None, description='The case-sensitive name of the group.'
    )
    InsightsConfiguration_1: Optional[InsightsConfiguration] = Field(
        None,
        alias='InsightsConfiguration',
        description='The structure containing configurations related to insights.',
    )


class AliasNames(RootModel[List[String]]):
    root: List[String]


class AnnotationValue(BaseModel):
    BooleanValue: Optional[NullableBoolean] = None
    NumberValue: Optional[NullableDouble] = None
    StringValue: Optional[String] = None


class AttributeMap(RootModel[Optional[Dict[str, AttributeValue]]]):
    root: Optional[Dict[str, AttributeValue]] = None


class AvailabilityZoneDetail(BaseModel):
    Name: Optional[String] = None


class BackendConnectionErrors(BaseModel):
    ConnectionRefusedCount: Optional[NullableInteger] = None
    HTTPCode4XXCount: Optional[NullableInteger] = None
    HTTPCode5XXCount: Optional[NullableInteger] = None
    OtherCount: Optional[NullableInteger] = None
    TimeoutCount: Optional[NullableInteger] = None
    UnknownHostCount: Optional[NullableInteger] = None


class BatchGetTracesRequest(BaseModel):
    NextToken: Optional[String] = None
    TraceIds: TraceIdList


class DeleteGroupRequest(BaseModel):
    GroupARN_1: Optional[GroupARN] = Field(None, alias='GroupARN')
    GroupName_1: Optional[GroupName] = Field(None, alias='GroupName')


class DeleteResourcePolicyRequest(BaseModel):
    PolicyName_1: PolicyName = Field(..., alias='PolicyName')
    PolicyRevisionId_1: Optional[PolicyRevisionId] = Field(
        None, alias='PolicyRevisionId'
    )


class DeleteSamplingRuleRequest(BaseModel):
    RuleARN: Optional[String] = None
    RuleName: Optional[String] = None


class EncryptionConfig(BaseModel):
    KeyId: Optional[String] = None
    Status: Optional[EncryptionStatus] = None
    Type: Optional[EncryptionType] = None


class ErrorStatistics(BaseModel):
    OtherCount: Optional[NullableLong] = None
    ThrottleCount: Optional[NullableLong] = None
    TotalCount: Optional[NullableLong] = None


class FaultStatistics(BaseModel):
    OtherCount: Optional[NullableLong] = None
    TotalCount: Optional[NullableLong] = None


class ForecastStatistics(BaseModel):
    FaultCountHigh: Optional[NullableLong] = None
    FaultCountLow: Optional[NullableLong] = None


class GetEncryptionConfigResult(BaseModel):
    EncryptionConfig_1: Optional[EncryptionConfig] = Field(
        None, alias='EncryptionConfig'
    )


class GetGroupRequest(BaseModel):
    GroupARN_1: Optional[GroupARN] = Field(None, alias='GroupARN')
    GroupName_1: Optional[GroupName] = Field(None, alias='GroupName')


class GetInsightEventsRequest(BaseModel):
    InsightId_1: InsightId = Field(..., alias='InsightId')
    MaxResults: Optional[GetInsightEventsMaxResults] = None
    NextToken: Optional[Token] = None


class GetInsightImpactGraphRequest(BaseModel):
    EndTime: Timestamp
    InsightId_1: InsightId = Field(..., alias='InsightId')
    NextToken: Optional[Token] = None
    StartTime: Timestamp


class GetInsightRequest(BaseModel):
    InsightId_1: InsightId = Field(..., alias='InsightId')


class GetInsightSummariesRequest(BaseModel):
    EndTime: Timestamp
    GroupARN_1: Optional[GroupARN] = Field(None, alias='GroupARN')
    GroupName_1: Optional[GroupName] = Field(None, alias='GroupName')
    MaxResults: Optional[GetInsightSummariesMaxResults] = None
    NextToken: Optional[Token] = None
    StartTime: Timestamp
    States: Optional[InsightStateList] = None


class GetSamplingRulesRequest(BaseModel):
    NextToken: Optional[String] = None


class GetSamplingStatisticSummariesRequest(BaseModel):
    NextToken: Optional[String] = None


class GetServiceGraphRequest(BaseModel):
    EndTime: Timestamp
    GroupARN_1: Optional[GroupARN] = Field(None, alias='GroupARN')
    GroupName_1: Optional[GroupName] = Field(None, alias='GroupName')
    NextToken: Optional[String] = None
    StartTime: Timestamp


class GetTimeSeriesServiceStatisticsRequest(BaseModel):
    EndTime: Timestamp
    EntitySelectorExpression_1: Optional[EntitySelectorExpression] = Field(
        None, alias='EntitySelectorExpression'
    )
    ForecastStatistics: Optional[NullableBoolean] = None
    GroupARN_1: Optional[GroupARN] = Field(None, alias='GroupARN')
    GroupName_1: Optional[GroupName] = Field(None, alias='GroupName')
    NextToken: Optional[String] = None
    Period: Optional[NullableInteger] = None
    StartTime: Timestamp


class GetTraceGraphRequest(BaseModel):
    NextToken: Optional[String] = None
    TraceIds: TraceIdList


class HistogramEntry(BaseModel):
    Count: Optional[Integer] = None
    Value: Optional[Double] = None


class Http(BaseModel):
    ClientIp: Optional[String] = None
    HttpMethod: Optional[String] = None
    HttpStatus: Optional[NullableInteger] = None
    HttpURL: Optional[String] = None
    UserAgent: Optional[String] = None


class InsightImpactGraphEdge(BaseModel):
    ReferenceId: Optional[NullableInteger] = None


class InsightImpactGraphEdgeList(RootModel[List[InsightImpactGraphEdge]]):
    root: List[InsightImpactGraphEdge]


class InstanceIdDetail(BaseModel):
    Id: Optional[String] = None


class ListResourcePoliciesRequest(BaseModel):
    NextToken: Optional[ResourcePolicyNextToken] = None


class ListTagsForResourceRequest(BaseModel):
    NextToken: Optional[String] = None
    ResourceARN: AmazonResourceName


class PutEncryptionConfigResult(BaseModel):
    EncryptionConfig_1: Optional[EncryptionConfig] = Field(
        None, alias='EncryptionConfig'
    )


class PutTraceSegmentsRequest(BaseModel):
    TraceSegmentDocuments: TraceSegmentDocumentList


class PutTraceSegmentsResult(BaseModel):
    UnprocessedTraceSegments: Optional[UnprocessedTraceSegmentList] = None


class ResourceARNDetail(BaseModel):
    ARN: Optional[String] = None


class ResourcePolicy(BaseModel):
    LastUpdatedTime: Optional[Timestamp] = None
    PolicyDocument_1: Optional[PolicyDocument] = Field(None, alias='PolicyDocument')
    PolicyName_1: Optional[PolicyName] = Field(None, alias='PolicyName')
    PolicyRevisionId_1: Optional[PolicyRevisionId] = Field(
        None, alias='PolicyRevisionId'
    )


class ResourcePolicyList(RootModel[List[ResourcePolicy]]):
    root: List[ResourcePolicy]


class ResponseTimeRootCauseEntity(BaseModel):
    Coverage: Optional[NullableDouble] = None
    Name: Optional[String] = None
    Remote: Optional[NullableBoolean] = None


class ResponseTimeRootCauseEntityPath(RootModel[List[ResponseTimeRootCauseEntity]]):
    root: List[ResponseTimeRootCauseEntity]


class RootCauseException(BaseModel):
    Message: Optional[String] = None
    Name: Optional[String] = None


class RootCauseExceptions(RootModel[List[RootCauseException]]):
    root: List[RootCauseException]


class SamplingRule(BaseModel):
    Attributes: Optional[AttributeMap] = None
    FixedRate_1: FixedRate = Field(..., alias='FixedRate')
    HTTPMethod_1: HTTPMethod = Field(..., alias='HTTPMethod')
    Host_1: Host = Field(..., alias='Host')
    Priority_1: Priority = Field(..., alias='Priority')
    ReservoirSize_1: ReservoirSize = Field(..., alias='ReservoirSize')
    ResourceARN_1: ResourceARN = Field(..., alias='ResourceARN')
    RuleARN: Optional[String] = None
    RuleName_1: Optional[RuleName] = Field(None, alias='RuleName')
    ServiceName_1: ServiceName = Field(..., alias='ServiceName')
    ServiceType_1: ServiceType = Field(..., alias='ServiceType')
    URLPath_1: URLPath = Field(..., alias='URLPath')
    Version_1: Version = Field(..., alias='Version')


class SamplingRuleRecord(BaseModel):
    CreatedAt: Optional[Timestamp] = None
    ModifiedAt: Optional[Timestamp] = None
    SamplingRule_1: Optional[SamplingRule] = Field(None, alias='SamplingRule')


class SamplingRuleRecordList(RootModel[List[SamplingRuleRecord]]):
    root: List[SamplingRuleRecord]


class SamplingRuleUpdate(BaseModel):
    Attributes: Optional[AttributeMap] = None
    FixedRate: Optional[NullableDouble] = None
    HTTPMethod_1: Optional[HTTPMethod] = Field(None, alias='HTTPMethod')
    Host_1: Optional[Host] = Field(None, alias='Host')
    Priority: Optional[NullableInteger] = None
    ReservoirSize: Optional[NullableInteger] = None
    ResourceARN_1: Optional[ResourceARN] = Field(None, alias='ResourceARN')
    RuleARN: Optional[String] = None
    RuleName_1: Optional[RuleName] = Field(None, alias='RuleName')
    ServiceName_1: Optional[ServiceName] = Field(None, alias='ServiceName')
    ServiceType_1: Optional[ServiceType] = Field(None, alias='ServiceType')
    URLPath_1: Optional[URLPath] = Field(None, alias='URLPath')


class SamplingStatisticSummary(BaseModel):
    BorrowCount: Optional[Integer] = None
    RequestCount: Optional[Integer] = None
    RuleName: Optional[String] = None
    SampledCount: Optional[Integer] = None
    Timestamp_1: Optional[Timestamp] = Field(None, alias='Timestamp')


class SamplingStatisticSummaryList(RootModel[List[SamplingStatisticSummary]]):
    root: List[SamplingStatisticSummary]


class SamplingStatisticsDocument(BaseModel):
    BorrowCount_1: Optional[BorrowCount] = Field(None, alias='BorrowCount')
    ClientID_1: ClientID = Field(..., alias='ClientID')
    RequestCount_1: RequestCount = Field(..., alias='RequestCount')
    RuleName_1: RuleName = Field(..., alias='RuleName')
    SampledCount_1: SampledCount = Field(..., alias='SampledCount')
    Timestamp_1: Timestamp = Field(..., alias='Timestamp')


class SamplingStatisticsDocumentList(RootModel[List[SamplingStatisticsDocument]]):
    root: List[SamplingStatisticsDocument] = Field(..., max_length=25)


class SamplingTargetDocument(BaseModel):
    FixedRate: Optional[Double] = None
    Interval: Optional[NullableInteger] = None
    ReservoirQuota: Optional[NullableInteger] = None
    ReservoirQuotaTTL: Optional[Timestamp] = None
    RuleName: Optional[String] = None


class SamplingTargetDocumentList(RootModel[List[SamplingTargetDocument]]):
    root: List[SamplingTargetDocument]


class Segment(BaseModel):
    Document: Optional[SegmentDocument] = None
    Id: Optional[SegmentId] = None


class SegmentList(RootModel[List[Segment]]):
    root: List[Segment]


class ServiceNames(RootModel[List[String]]):
    root: List[String]


class ServiceStatistics(BaseModel):
    ErrorStatistics_1: Optional[ErrorStatistics] = Field(None, alias='ErrorStatistics')
    FaultStatistics_1: Optional[FaultStatistics] = Field(None, alias='FaultStatistics')
    OkCount: Optional[NullableLong] = None
    TotalCount: Optional[NullableLong] = None
    TotalResponseTime: Optional[NullableDouble] = None


class Tag(BaseModel):
    Key: TagKey
    Value: TagValue


class TagList(RootModel[List[Tag]]):
    root: List[Tag] = Field(..., max_length=200, min_length=0)


class TagResourceRequest(BaseModel):
    ResourceARN: AmazonResourceName
    Tags: TagList


class TelemetryRecord(BaseModel):
    BackendConnectionErrors_1: Optional[BackendConnectionErrors] = Field(
        None, alias='BackendConnectionErrors'
    )
    SegmentsReceivedCount: Optional[NullableInteger] = None
    SegmentsRejectedCount: Optional[NullableInteger] = None
    SegmentsSentCount: Optional[NullableInteger] = None
    SegmentsSpilloverCount: Optional[NullableInteger] = None
    Timestamp_1: Timestamp = Field(..., alias='Timestamp')


class TelemetryRecordList(RootModel[List[TelemetryRecord]]):
    root: List[TelemetryRecord]


class Trace(BaseModel):
    Duration: Optional[NullableDouble] = None
    Id: Optional[TraceId] = None
    LimitExceeded: Optional[NullableBoolean] = None
    Segments: Optional[SegmentList] = None


class TraceAvailabilityZones(RootModel[List[AvailabilityZoneDetail]]):
    root: List[AvailabilityZoneDetail]


class TraceInstanceIds(RootModel[List[InstanceIdDetail]]):
    root: List[InstanceIdDetail]


class TraceList(RootModel[List[Trace]]):
    root: List[Trace]


class TraceResourceARNs(RootModel[List[ResourceARNDetail]]):
    root: List[ResourceARNDetail]


class UpdateGroupRequest(BaseModel):
    FilterExpression_1: Optional[FilterExpression] = Field(
        None, alias='FilterExpression'
    )
    GroupARN_1: Optional[GroupARN] = Field(None, alias='GroupARN')
    GroupName_1: Optional[GroupName] = Field(None, alias='GroupName')
    InsightsConfiguration_1: Optional[InsightsConfiguration] = Field(
        None, alias='InsightsConfiguration'
    )


class UpdateSamplingRuleRequest(BaseModel):
    SamplingRuleUpdate_1: SamplingRuleUpdate = Field(..., alias='SamplingRuleUpdate')


class UpdateSamplingRuleResult(BaseModel):
    SamplingRuleRecord_1: Optional[SamplingRuleRecord] = Field(
        None, alias='SamplingRuleRecord'
    )


class CreateGroupPostRequest(BaseModel):
    FilterExpression: Optional[str] = Field(
        None,
        description='The filter expression defining criteria by which to group traces.',
    )
    GroupName: constr(min_length=1, max_length=32) = Field(
        ...,
        description='The case-sensitive name of the new group. Default is a reserved name and names must be unique.',
    )
    InsightsConfiguration_1: Optional[InsightsConfiguration] = Field(
        None,
        alias='InsightsConfiguration',
        description='The structure containing configurations related to insights.',
    )
    Tags: Optional[List[Tag]] = Field(
        None,
        description='<p>A map that contains one or more tag keys and tag values to attach to an X-Ray group. For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference</i>.</p> <p>The following restrictions apply to tags:</p> <ul> <li> <p>Maximum number of user-applied tags per resource: 50</p> </li> <li> <p>Maximum tag key length: 128 Unicode characters</p> </li> <li> <p>Maximum tag value length: 256 Unicode characters</p> </li> <li> <p>Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @</p> </li> <li> <p>Tag keys and values are case sensitive.</p> </li> <li> <p>Don\'t use <code>aws:</code> as a prefix for keys; it\'s reserved for Amazon Web Services use.</p> </li> </ul>',
        max_length=200,
        min_length=0,
    )


class SamplingRule1(BaseModel):
    Attributes: Optional[AttributeMap] = None
    FixedRate_1: Optional[FixedRate] = Field(None, alias='FixedRate')
    HTTPMethod_1: Optional[HTTPMethod] = Field(None, alias='HTTPMethod')
    Host_1: Optional[Host] = Field(None, alias='Host')
    Priority_1: Optional[Priority] = Field(None, alias='Priority')
    ReservoirSize_1: Optional[ReservoirSize] = Field(None, alias='ReservoirSize')
    ResourceARN_1: Optional[ResourceARN] = Field(None, alias='ResourceARN')
    RuleARN: Optional[String] = None
    RuleName_1: Optional[RuleName] = Field(None, alias='RuleName')
    ServiceName_1: Optional[ServiceName] = Field(None, alias='ServiceName')
    ServiceType_1: Optional[ServiceType] = Field(None, alias='ServiceType')
    URLPath_1: Optional[URLPath] = Field(None, alias='URLPath')
    Version_1: Optional[Version] = Field(None, alias='Version')


class CreateSamplingRulePostRequest(BaseModel):
    SamplingRule: SamplingRule1 = Field(
        ...,
        description="A sampling rule that services use to decide whether to instrument a request. Rule fields can match properties of the service, or properties of a request. The service can ignore rules that don't match its properties.",
    )
    Tags: Optional[List[Tag]] = Field(
        None,
        description='<p>A map that contains one or more tag keys and tag values to attach to an X-Ray sampling rule. For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference</i>.</p> <p>The following restrictions apply to tags:</p> <ul> <li> <p>Maximum number of user-applied tags per resource: 50</p> </li> <li> <p>Maximum tag key length: 128 Unicode characters</p> </li> <li> <p>Maximum tag value length: 256 Unicode characters</p> </li> <li> <p>Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @</p> </li> <li> <p>Tag keys and values are case sensitive.</p> </li> <li> <p>Don\'t use <code>aws:</code> as a prefix for keys; it\'s reserved for Amazon Web Services use.</p> </li> </ul>',
        max_length=200,
        min_length=0,
    )


class SamplingTargetsPostRequest(BaseModel):
    SamplingStatisticsDocuments: List[SamplingStatisticsDocument] = Field(
        ...,
        description='Information about rules that the service is using to sample requests.',
        max_length=25,
    )


class TagResourcePostRequest(BaseModel):
    ResourceARN: constr(min_length=1, max_length=1011) = Field(
        ...,
        description='The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.',
    )
    Tags: List[Tag] = Field(
        ...,
        description='<p>A map that contains one or more tag keys and tag values to attach to an X-Ray group or sampling rule. For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference</i>.</p> <p>The following restrictions apply to tags:</p> <ul> <li> <p>Maximum number of user-applied tags per resource: 50</p> </li> <li> <p>Maximum tag key length: 128 Unicode characters</p> </li> <li> <p>Maximum tag value length: 256 Unicode characters</p> </li> <li> <p>Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . : / = + - and @</p> </li> <li> <p>Tag keys and values are case sensitive.</p> </li> <li> <p>Don\'t use <code>aws:</code> as a prefix for keys; it\'s reserved for Amazon Web Services use. You cannot edit or delete system tags.</p> </li> </ul>',
        max_length=200,
        min_length=0,
    )


class TelemetryRecordsPostRequest(BaseModel):
    EC2InstanceId: Optional[constr(max_length=20)] = Field(None, description='<p/>')
    Hostname: Optional[constr(max_length=255)] = Field(None, description='<p/>')
    ResourceARN: Optional[constr(max_length=500)] = Field(None, description='<p/>')
    TelemetryRecords: List[TelemetryRecord] = Field(..., description='<p/>')


class UpdateSamplingRulePostRequest(BaseModel):
    SamplingRuleUpdate_1: SamplingRuleUpdate = Field(
        ...,
        alias='SamplingRuleUpdate',
        description="A document specifying changes to a sampling rule's configuration.",
    )


class Alias(BaseModel):
    Name: Optional[String] = None
    Names: Optional[AliasNames] = None
    Type: Optional[String] = None


class AliasList(RootModel[List[Alias]]):
    root: List[Alias]


class BatchGetTracesResult(BaseModel):
    NextToken: Optional[String] = None
    Traces: Optional[TraceList] = None
    UnprocessedTraceIds: Optional[UnprocessedTraceIdList] = None


class CreateGroupRequest(BaseModel):
    FilterExpression_1: Optional[FilterExpression] = Field(
        None, alias='FilterExpression'
    )
    GroupName_1: GroupName = Field(..., alias='GroupName')
    InsightsConfiguration_1: Optional[InsightsConfiguration] = Field(
        None, alias='InsightsConfiguration'
    )
    Tags: Optional[TagList] = None


class CreateSamplingRuleRequest(BaseModel):
    SamplingRule_1: SamplingRule = Field(..., alias='SamplingRule')
    Tags: Optional[TagList] = None


class CreateSamplingRuleResult(BaseModel):
    SamplingRuleRecord_1: Optional[SamplingRuleRecord] = Field(
        None, alias='SamplingRuleRecord'
    )


class DeleteSamplingRuleResult(BaseModel):
    SamplingRuleRecord_1: Optional[SamplingRuleRecord] = Field(
        None, alias='SamplingRuleRecord'
    )


class EdgeStatistics(BaseModel):
    ErrorStatistics_1: Optional[ErrorStatistics] = Field(None, alias='ErrorStatistics')
    FaultStatistics_1: Optional[FaultStatistics] = Field(None, alias='FaultStatistics')
    OkCount: Optional[NullableLong] = None
    TotalCount: Optional[NullableLong] = None
    TotalResponseTime: Optional[NullableDouble] = None


class ErrorRootCauseEntity(BaseModel):
    Exceptions: Optional[RootCauseExceptions] = None
    Name: Optional[String] = None
    Remote: Optional[NullableBoolean] = None


class ErrorRootCauseEntityPath(RootModel[List[ErrorRootCauseEntity]]):
    root: List[ErrorRootCauseEntity]


class ErrorRootCauseService(BaseModel):
    AccountId: Optional[String] = None
    EntityPath: Optional[ErrorRootCauseEntityPath] = None
    Inferred: Optional[NullableBoolean] = None
    Name: Optional[String] = None
    Names: Optional[ServiceNames] = None
    Type: Optional[String] = None


class ErrorRootCauseServices(RootModel[List[ErrorRootCauseService]]):
    root: List[ErrorRootCauseService]


class FaultRootCauseEntity(BaseModel):
    Exceptions: Optional[RootCauseExceptions] = None
    Name: Optional[String] = None
    Remote: Optional[NullableBoolean] = None


class FaultRootCauseEntityPath(RootModel[List[FaultRootCauseEntity]]):
    root: List[FaultRootCauseEntity]


class FaultRootCauseService(BaseModel):
    AccountId: Optional[String] = None
    EntityPath: Optional[FaultRootCauseEntityPath] = None
    Inferred: Optional[NullableBoolean] = None
    Name: Optional[String] = None
    Names: Optional[ServiceNames] = None
    Type: Optional[String] = None


class FaultRootCauseServices(RootModel[List[FaultRootCauseService]]):
    root: List[FaultRootCauseService]


class GetSamplingRulesResult(BaseModel):
    NextToken: Optional[String] = None
    SamplingRuleRecords: Optional[SamplingRuleRecordList] = None


class GetSamplingStatisticSummariesResult(BaseModel):
    NextToken: Optional[String] = None
    SamplingStatisticSummaries: Optional[SamplingStatisticSummaryList] = None


class GetSamplingTargetsRequest(BaseModel):
    SamplingStatisticsDocuments: SamplingStatisticsDocumentList


class GetSamplingTargetsResult(BaseModel):
    LastRuleModification: Optional[Timestamp] = None
    SamplingTargetDocuments: Optional[SamplingTargetDocumentList] = None
    UnprocessedStatistics: Optional[UnprocessedStatisticsList] = None


class GetTraceSummariesRequest(BaseModel):
    EndTime: Timestamp
    FilterExpression_1: Optional[FilterExpression] = Field(
        None, alias='FilterExpression'
    )
    NextToken: Optional[String] = None
    Sampling: Optional[NullableBoolean] = None
    SamplingStrategy_1: Optional[SamplingStrategy] = Field(
        None, alias='SamplingStrategy'
    )
    StartTime: Timestamp
    TimeRangeType_1: Optional[TimeRangeType] = Field(None, alias='TimeRangeType')


class Group(BaseModel):
    FilterExpression: Optional[String] = None
    GroupARN: Optional[String] = None
    GroupName: Optional[String] = None
    InsightsConfiguration_1: Optional[InsightsConfiguration] = Field(
        None, alias='InsightsConfiguration'
    )


class GroupSummary(BaseModel):
    FilterExpression: Optional[String] = None
    GroupARN: Optional[String] = None
    GroupName: Optional[String] = None
    InsightsConfiguration_1: Optional[InsightsConfiguration] = Field(
        None, alias='InsightsConfiguration'
    )


class GroupSummaryList(RootModel[List[GroupSummary]]):
    root: List[GroupSummary]


class Histogram(RootModel[List[HistogramEntry]]):
    root: List[HistogramEntry]


class InsightImpactGraphService(BaseModel):
    AccountId: Optional[String] = None
    Edges: Optional[InsightImpactGraphEdgeList] = None
    Name: Optional[String] = None
    Names: Optional[ServiceNames] = None
    ReferenceId: Optional[NullableInteger] = None
    Type: Optional[String] = None


class InsightImpactGraphServiceList(RootModel[List[InsightImpactGraphService]]):
    root: List[InsightImpactGraphService]


class ListResourcePoliciesResult(BaseModel):
    NextToken: Optional[ResourcePolicyNextToken] = None
    ResourcePolicies: Optional[ResourcePolicyList] = None


class ListTagsForResourceResponse(BaseModel):
    NextToken: Optional[String] = None
    Tags: Optional[TagList] = None


class PutResourcePolicyResult(BaseModel):
    ResourcePolicy_1: Optional[ResourcePolicy] = Field(None, alias='ResourcePolicy')


class PutTelemetryRecordsRequest(BaseModel):
    EC2InstanceId_1: Optional[EC2InstanceId] = Field(None, alias='EC2InstanceId')
    Hostname_1: Optional[Hostname] = Field(None, alias='Hostname')
    ResourceARN_1: Optional[ResourceARN] = Field(None, alias='ResourceARN')
    TelemetryRecords: TelemetryRecordList


class ResponseTimeRootCauseService(BaseModel):
    AccountId: Optional[String] = None
    EntityPath: Optional[ResponseTimeRootCauseEntityPath] = None
    Inferred: Optional[NullableBoolean] = None
    Name: Optional[String] = None
    Names: Optional[ServiceNames] = None
    Type: Optional[String] = None


class ResponseTimeRootCauseServices(RootModel[List[ResponseTimeRootCauseService]]):
    root: List[ResponseTimeRootCauseService]


class ServiceId(BaseModel):
    AccountId: Optional[String] = None
    Name: Optional[String] = None
    Names: Optional[ServiceNames] = None
    Type: Optional[String] = None


class ServiceIds(RootModel[List[ServiceId]]):
    root: List[ServiceId]


class TimeSeriesServiceStatistics(BaseModel):
    EdgeSummaryStatistics: Optional[EdgeStatistics] = None
    ResponseTimeHistogram: Optional[Histogram] = None
    ServiceForecastStatistics: Optional[ForecastStatistics] = None
    ServiceSummaryStatistics: Optional[ServiceStatistics] = None
    Timestamp_1: Optional[Timestamp] = Field(None, alias='Timestamp')


class TimeSeriesServiceStatisticsList(RootModel[List[TimeSeriesServiceStatistics]]):
    root: List[TimeSeriesServiceStatistics]


class TraceUser(BaseModel):
    ServiceIds_1: Optional[ServiceIds] = Field(None, alias='ServiceIds')
    UserName: Optional[String] = None


class TraceUsers(RootModel[List[TraceUser]]):
    root: List[TraceUser]


class UpdateGroupResult(BaseModel):
    Group_1: Optional[Group] = Field(None, alias='Group')


class ValueWithServiceIds(BaseModel):
    AnnotationValue_1: Optional[AnnotationValue] = Field(None, alias='AnnotationValue')
    ServiceIds_1: Optional[ServiceIds] = Field(None, alias='ServiceIds')


class ValuesWithServiceIds(RootModel[List[ValueWithServiceIds]]):
    root: List[ValueWithServiceIds]


class Annotations(RootModel[Optional[Dict[str, ValuesWithServiceIds]]]):
    root: Optional[Dict[str, ValuesWithServiceIds]] = None


class AnomalousService(BaseModel):
    ServiceId_1: Optional[ServiceId] = Field(None, alias='ServiceId')


class AnomalousServiceList(RootModel[List[AnomalousService]]):
    root: List[AnomalousService]


class CreateGroupResult(BaseModel):
    Group_1: Optional[Group] = Field(None, alias='Group')


class Edge(BaseModel):
    Aliases: Optional[AliasList] = None
    EdgeType: Optional[String] = None
    EndTime: Optional[Timestamp] = None
    ReceivedEventAgeHistogram: Optional[Histogram] = None
    ReferenceId: Optional[NullableInteger] = None
    ResponseTimeHistogram: Optional[Histogram] = None
    StartTime: Optional[Timestamp] = None
    SummaryStatistics: Optional[EdgeStatistics] = None


class EdgeList(RootModel[List[Edge]]):
    root: List[Edge]


class ErrorRootCause(BaseModel):
    ClientImpacting: Optional[NullableBoolean] = None
    Services: Optional[ErrorRootCauseServices] = None


class ErrorRootCauses(RootModel[List[ErrorRootCause]]):
    root: List[ErrorRootCause]


class FaultRootCause(BaseModel):
    ClientImpacting: Optional[NullableBoolean] = None
    Services: Optional[FaultRootCauseServices] = None


class FaultRootCauses(RootModel[List[FaultRootCause]]):
    root: List[FaultRootCause]


class GetGroupResult(BaseModel):
    Group_1: Optional[Group] = Field(None, alias='Group')


class GetGroupsResult(BaseModel):
    Groups: Optional[GroupSummaryList] = None
    NextToken: Optional[String] = None


class GetInsightImpactGraphResult(BaseModel):
    EndTime: Optional[Timestamp] = None
    InsightId_1: Optional[InsightId] = Field(None, alias='InsightId')
    NextToken: Optional[Token] = None
    ServiceGraphEndTime: Optional[Timestamp] = None
    ServiceGraphStartTime: Optional[Timestamp] = None
    Services: Optional[InsightImpactGraphServiceList] = None
    StartTime: Optional[Timestamp] = None


class GetTimeSeriesServiceStatisticsResult(BaseModel):
    ContainsOldGroupVersions: Optional[Boolean] = None
    NextToken: Optional[String] = None
    TimeSeriesServiceStatistics: Optional[TimeSeriesServiceStatisticsList] = None


class Insight(BaseModel):
    Categories: Optional[InsightCategoryList] = None
    ClientRequestImpactStatistics: Optional[RequestImpactStatistics] = None
    EndTime: Optional[Timestamp] = None
    GroupARN_1: Optional[GroupARN] = Field(None, alias='GroupARN')
    GroupName_1: Optional[GroupName] = Field(None, alias='GroupName')
    InsightId_1: Optional[InsightId] = Field(None, alias='InsightId')
    RootCauseServiceId: Optional[ServiceId] = None
    RootCauseServiceRequestImpactStatistics: Optional[RequestImpactStatistics] = None
    StartTime: Optional[Timestamp] = None
    State: Optional[InsightState] = None
    Summary: Optional[InsightSummaryText] = None
    TopAnomalousServices: Optional[AnomalousServiceList] = None


class InsightEvent(BaseModel):
    ClientRequestImpactStatistics: Optional[RequestImpactStatistics] = None
    EventTime: Optional[Timestamp] = None
    RootCauseServiceRequestImpactStatistics: Optional[RequestImpactStatistics] = None
    Summary: Optional[EventSummaryText] = None
    TopAnomalousServices: Optional[AnomalousServiceList] = None


class InsightEventList(RootModel[List[InsightEvent]]):
    root: List[InsightEvent]


class InsightSummary(BaseModel):
    Categories: Optional[InsightCategoryList] = None
    ClientRequestImpactStatistics: Optional[RequestImpactStatistics] = None
    EndTime: Optional[Timestamp] = None
    GroupARN_1: Optional[GroupARN] = Field(None, alias='GroupARN')
    GroupName_1: Optional[GroupName] = Field(None, alias='GroupName')
    InsightId_1: Optional[InsightId] = Field(None, alias='InsightId')
    LastUpdateTime: Optional[Timestamp] = None
    RootCauseServiceId: Optional[ServiceId] = None
    RootCauseServiceRequestImpactStatistics: Optional[RequestImpactStatistics] = None
    StartTime: Optional[Timestamp] = None
    State: Optional[InsightState] = None
    Summary: Optional[InsightSummaryText] = None
    TopAnomalousServices: Optional[AnomalousServiceList] = None


class InsightSummaryList(RootModel[List[InsightSummary]]):
    root: List[InsightSummary]


class ResponseTimeRootCause(BaseModel):
    ClientImpacting: Optional[NullableBoolean] = None
    Services: Optional[ResponseTimeRootCauseServices] = None


class ResponseTimeRootCauses(RootModel[List[ResponseTimeRootCause]]):
    root: List[ResponseTimeRootCause]


class Service(BaseModel):
    AccountId: Optional[String] = None
    DurationHistogram: Optional[Histogram] = None
    Edges: Optional[EdgeList] = None
    EndTime: Optional[Timestamp] = None
    Name: Optional[String] = None
    Names: Optional[ServiceNames] = None
    ReferenceId: Optional[NullableInteger] = None
    ResponseTimeHistogram: Optional[Histogram] = None
    Root: Optional[NullableBoolean] = None
    StartTime: Optional[Timestamp] = None
    State: Optional[String] = None
    SummaryStatistics: Optional[ServiceStatistics] = None
    Type: Optional[String] = None


class ServiceList(RootModel[List[Service]]):
    root: List[Service]


class TraceSummary(BaseModel):
    Annotations_1: Optional[Annotations] = Field(None, alias='Annotations')
    AvailabilityZones: Optional[TraceAvailabilityZones] = None
    Duration: Optional[NullableDouble] = None
    EntryPoint: Optional[ServiceId] = None
    ErrorRootCauses_1: Optional[ErrorRootCauses] = Field(None, alias='ErrorRootCauses')
    FaultRootCauses_1: Optional[FaultRootCauses] = Field(None, alias='FaultRootCauses')
    HasError: Optional[NullableBoolean] = None
    HasFault: Optional[NullableBoolean] = None
    HasThrottle: Optional[NullableBoolean] = None
    Http_1: Optional[Http] = Field(None, alias='Http')
    Id: Optional[TraceId] = None
    InstanceIds: Optional[TraceInstanceIds] = None
    IsPartial: Optional[NullableBoolean] = None
    MatchedEventTime: Optional[Timestamp] = None
    ResourceARNs: Optional[TraceResourceARNs] = None
    ResponseTime: Optional[NullableDouble] = None
    ResponseTimeRootCauses_1: Optional[ResponseTimeRootCauses] = Field(
        None, alias='ResponseTimeRootCauses'
    )
    Revision: Optional[Integer] = None
    ServiceIds_1: Optional[ServiceIds] = Field(None, alias='ServiceIds')
    Users: Optional[TraceUsers] = None


class TraceSummaryList(RootModel[List[TraceSummary]]):
    root: List[TraceSummary]


class GetInsightEventsResult(BaseModel):
    InsightEvents: Optional[InsightEventList] = None
    NextToken: Optional[Token] = None


class GetInsightResult(BaseModel):
    Insight_1: Optional[Insight] = Field(None, alias='Insight')


class GetInsightSummariesResult(BaseModel):
    InsightSummaries: Optional[InsightSummaryList] = None
    NextToken: Optional[Token] = None


class GetServiceGraphResult(BaseModel):
    ContainsOldGroupVersions: Optional[Boolean] = None
    EndTime: Optional[Timestamp] = None
    NextToken: Optional[String] = None
    Services: Optional[ServiceList] = None
    StartTime: Optional[Timestamp] = None


class GetTraceGraphResult(BaseModel):
    NextToken: Optional[String] = None
    Services: Optional[ServiceList] = None


class GetTraceSummariesResult(BaseModel):
    ApproximateTime: Optional[Timestamp] = None
    NextToken: Optional[String] = None
    TraceSummaries: Optional[TraceSummaryList] = None
    TracesProcessedCount: Optional[NullableLong] = None
